# 스프링 부트로 마이크로서비스 구축

지금까지의 대형(책에는 매머드급 프로젝트)프로젝트들은 폭포수(Waterfall) 방식으로 개발하는 경향이 있었대요. 확실히 설계하고 분석하려는 하기 때문인 것 같은데 초기 실책에 대한 방어 비용이 무지막지 할 수 있어요.
> 하지만 실제 소프트웨어 개발은 정의(definition)과 실행(execution)의 과정이 아니라 개발에 필요한 요소를 확실히 이해하도록 고객과 소통하고 배워가는 활동들의 진화 과정이래요.  
> - p.89

멋진 말이네요. ~~하지만 기술에 대한 러닝커브가 아닌 비지니스에 대한 러닝커브에 대해서 개발자가 감당하는걸 꺼려해서... 그냥 나만의 생각일까요?~~  

폭포수 방법론의 단점은

- ##### 강한 결합(tightly coupling)
비지니스 로직이 중립적인 프로토콜 수준이 아닌 프로그래밍 언어 수준에서 이루어져서 새로운 버그를 생산할 가능성이 높아진다는데, 정말 그럴까요? 추상화된 규약을 지키는게 좋다는 건 이해하겠는데 책에 말한건 이해가 잘 안되네요.

- ###### 누설(leaky)
분리된 데이터 모델을 아무렇게나 넘나든다는 얘기 같아요. 하나의 컴포넌트가 여러 데이터 모델에 의존성을 가지고있어 데이터베이스 테이블이 변경되면 여파가 커질 수 있다는 거죠.

- ##### 모놀리식(monolithic)
큰 덩어리가 전체 컴파일되고 전과정을 테스트하는게 부담이 되는 거겠죠, 계속 변경될 때마다. 갈수록 힘들어지고요.

그에 반해 마이크로서비스 기반 아키텍쳐는
- ##### 제한(constrained)
하나의 책임 집합을 가져 범위가 좁고, `어플리케이션이 한가지 일을 하며, 정말 잘하는 서비스 집합에 불과하다` 는 유닉스 철학을 수용 한다는데, 그런 유니스 철학이 있는지 처음 알았네요.

- ##### 느스한 결합(loosely coupled)
작은 서비스의 집합이고 중립적인 인터페이스(REST, JSON)를 쓰니까 구현이 자유로워요.

- ##### 추상화 (abstract)
데이터 모델을 소유하고 장악(?)해서 통제가 가능하네요.

- ##### 독립적(independent)
서비스별로 개별적인 구성이니까 컴파일, 테스트, 배포가 가벼워서 이익이겠죠?

이러한 특징으로 클라우드랑 짬뽕되면 쿵짝이 왜 좋은지 알아볼까요?
- ##### 사용자층이 다양하고 대규모이다.
짧은 릴리즈 주기에 대응이 돼요.

- ##### 상당한 작동시간(uptime)이 요구된다.
따로 노니까 어플리케이션의 작동 중지 시간(downtime) 이 짧고, 고장난 것에서 격리도 쉽고 뭐하나 아쉬운게 없네요.

- ##### 볼륨이 균일하지 않다.
서비스 특성에 맞게 물리적인 가용 공간을 자유롭게 확장하고 축소할 수 있다는 거죠.

이런 마이크로서비스 개발은 중요한 세 역할로 이루는데,

- ##### 아키텍트(architect)
전체를 조망하며 각 서비스(또는 컴포넌트) 별로 분해하고 각각이 상호작용하는 방법을 이해하는 역할이래요.

- ##### 개발자(DEVELOPER)
그냥 개발자. 자(사)랑스런내 직업. 

- ##### 데브옵스 (devops)
모두가 아는 그 일. 배포와 운영.

## 2.1 아키텍트의 이야기: 마이크로서비스 아키텍쳐 설계

### 2.1.1 비지니스 문제의 분해

복잡한 문제를 덩어리 덩어리로 분리해 놓으면 다른 덩어리의 사사로운 것들은 기억하지 않아도 되는 거죠.
**덩어리로 추상화하고 그 안에서는 캡슐화**해요.

비지니스 영역 분리는 이분법적인 과학이기보단 예술에 가깝다네요. ~~감각이 없으면 할 수 없는 영역이란 얘기?!!! 그럼 난, 여기서 이만...~~

분해하는 지침으로

#### 1. 비지니스 문제를 기술하면서 사용된 명사에 주목하라.
반복되는 명사에 핵심 비지니스 영역이 도출된대요.

#### 2. 동사에 주목하라.
동사는 행위를 묘사하고, 해야 할 일을 도출한다는 거네요.

#### 3. 데이터의 응집성을 찾아라.
앞서 얘기한 바 있는데, 자기 데이터를 완전히 장악해야해요. 서로 연관성 높은 데이의 부분을 찾아요.

### 2.1.2 서비스 세분화의 확정

세분화하기 위한 해결책은
1. 큰 마이크로서비스에 시작해 작게 리팩토링하는 게 더 낫다.
2. 서비스간 교류하는 방식에 먼저 집중한다.
3. 문제 영역에 대한 이해가 깊어짐에 따라 서비스 책임도 계속 변한다.

> 나쁜 마이크로서비스의 징후
> - 책임이 너무 많은 서비스
> - 많은 테이블의 데이터를 관리하는 서비스
> - 과다한 테스트 케이스 
> - 한 문제 영역 부분에 속한 서비스가 토끼처럼 번식
> - 지나치게 상호 의존적
> - 단순한 CRUD 의 집합

### 2.1.3 서비스 사이의 대화: 서비스 인터페이스

- ##### 1. REST 철학을 수용하라.
HTTP 메서드 기반으로 기본 행동을 모델링 해요.

- ##### 2. URI 를 사용해 의도(intent)를 전달하라.
위의 1번이 내포하는 의미인 것 같은데...

- ##### 3. 요청과 응답에 JSON 을 사용하라.
경량에 가독성을 가지고 쓰기 쉬우니까.

- ##### 4. HTTP 상태코드로 결과를 전달하라.
이미 잘 정립되어있고 친숙하니까.

## 2.2 마이크로서비스를 사용하지 않아야 할 때

### 2.2.1 분산 시스템 구축의 복잡성
자동화된 시스템을 분산된 환경에서 운영할 수 있는 숙련도가 없다면 땡!

### 2.2.2 서버 스프롤(Server Sprawl)
우후죽순 생겨날 물리적인 서버를 감당할 수 없으면 땡!

### 2.2.3 애플리케이션 유형
조그만한 결과물을 위한거면 그냥 하나로 뭉쳐있는 모놀리틱으로 해요.

### 2.2.4 데이터 변환과 일관성
여러 테이블의 다양한 데이터를 취합하고 조합하는 작업은 과도한 책임과 성능 이슈가 생겨서 분산 환경에 부적합 경우가 생기니까 그럴 땐 지양해요.


## 2.3 개발자 이야기: 스프링 부트와 자바로 마이크로서비스 생성

### 2.3.1 기본 골격 프로젝트로 시작

[코드](./src/main/java)로 보세요.


## 2.4 데브옵스 이야기: 혹독한 런타임 구축
![](02.01.png)

#### 2.4.1 서비스 어셈블리: 마이크로서비스의 패키징과 배포
어플리케이션 서버(WAS)와 어플리케이션을 분리하면서 배포과정에서 문제점이 발생하죠. 구성 편차(configuration drift) 로 인한 문제 들이겠죠?

내장형 런타임 엔진을 포함해서 단일 산출물로 배포하면 걱정 끝!

#### 2.4.2 서비스 부트스트래핑: 마이크로서비스의 구성 관리
구성 데이터를 외부 데이터 저장소에 관리하면 여러 서버 인스턴스가 공유해서 사용할 수 있는데, 문제가 있대요. ~~딱히 문제점이라고 인식하지 못함, 개인적으론.~~

1. 데이터가 정기적으로 액세스 되지만 드물게 변경되므로 읽기 지연 시간이 짧아야 함
2. 데이터 저장소는 가용성이 좋아야하고, 완전히 중단할 수 없어야 한대요.

#### 2.4.3 서비스 등록과 디스커버리: 클라이언트가 마이크로서비스와 통신하는 방법
소비자 관점에서 서비스는 위치 투명성을 가져야 한대요. 클라우드 환경은 일시적이니까요.
그래서 인스턴스를 제 3자 에이전트에 스스로 등록해야 하는데, 이 등록 과정을 **서비스 디스커버리**라고 한대요.

#### 2.4.4 마이크로서비스의 상태 전달
서비스 디스커버리 에이전트는 위치 안내만 하는게 아니고 상태 모니터링도 해요. 클라이언트가 고장 난 인스턴스를 호출하지 않도록 잘(?) 라우팅 해야겠죠.  
스프링 부트의 actuator 를 이용해서 상태 확인 하는 거죠.

### 2.5 모든 관점에서
데브옵스, 개발자, 아키텍트가 잘 화합해야 서비스가 잘된다는 얘기겠죠. ~~모놀리틱에서 그렇게만 되면 다 잘 됨;;~~

### 2.6 요약
- 세 역할자가 화합해야 잘 된대요.
- MSA는 장단점이 있으니 잘 판단하시라.
- MSA는 소규모 서비스를 지향하고 데이터가 거기에 맞게 관리하세요.
- RESTful 하고 JSON 잘 써보시고,
- 데브옵스는 패키징하고 배포, 모니터링 잘 하라는데, 그냥 개발자가 알아서 다하는 것들.

---
아직까지 맛보긴 것 같은데, 뭔가 본격적인 서비스 개발은 언제부터 할랑가요?!

 
